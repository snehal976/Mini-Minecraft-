<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mini Minecraft - Beautiful World</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Elements - Vibrant Gaming Theme */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            font-family: 'Verdana', sans-serif;
            font-size: 14px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            user-select: none;
            z-index: 5;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #00ffff;
            border-radius: 8px;
        }

        /* Health Bar */
        #health-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 25px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 15px;
            z-index: 25;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.3);
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4444);
            transition: width 0.2s;
        }
        #health-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            z-index: 2;
        }

        /* AI Message Area */
        #ai-message-area {
            position: absolute;
            top: 80px;
            left: 20px;
            width: 300px;
            color: #b388ff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-shadow: 1px 1px 0 #000;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-left: 3px solid #b388ff;
            display: none;
            pointer-events: none;
            z-index: 5;
            animation: slideIn 0.5s ease-out;
        }
        @keyframes slideIn { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* Inventory Screen */
        #inventory-screen {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 60%; height: 60%;
            background: rgba(20, 20, 30, 0.95);
            border: 4px solid #00ffff;
            border-radius: 15px;
            z-index: 100;
            padding: 20px;
            color: #fff;
            font-family: 'Verdana', sans-serif;
            box-shadow: 0 0 30px #00ffff;
            flex-direction: column;
        }
        .inv-header {
            font-size: 24px;
            color: #00ffff;
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .inv-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            overflow-y: auto;
            flex-grow: 1;
        }
        .inv-item {
            width: 60px; height: 60px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            text-align: center;
            cursor: pointer;
            position: relative;
        }
        .inv-item:hover { border-color: #00ffff; }
        .inv-item img { width: 100%; height: 100%; image-rendering: pixelated; }

        /* Minimap */
        #minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 50%; /* Radar style */
            z-index: 25;
            overflow: hidden;
            box-shadow: 0 0 15px #00ffff;
        }
        #minimap {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Guiding Arrow */
        #guide-container {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        #guide-arrow {
            font-size: 50px;
            color: #ff00ff;
            text-shadow: 0 0 10px #00ffff;
            transition: transform 0.1s;
            animation: bounceArrow 1s infinite alternate;
        }
        @keyframes bounceArrow { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        
        #guide-text {
            color: #fff;
            font-family: 'Verdana', sans-serif;
            text-shadow: 2px 2px 0 #000;
            margin-top: 5px;
            font-weight: bold;
            font-size: 18px;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            padding: 8px 16px;
            border-radius: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }

        /* Chase Warning */
        #chase-warning {
            display: none;
            color: #ff0000;
            font-size: 24px;
            font-weight: 900;
            text-shadow: 0 0 10px #ff0000;
            margin-top: 5px;
            animation: pulseWarning 0.5s infinite;
        }
        @keyframes pulseWarning { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2b1055, #7597de);
            top: 0; left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 15;
            flex-direction: column;
            color: #fff;
            font-family: 'Verdana', sans-serif;
            text-align: center;
        }
        
        #instructions {
            background: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border: 4px solid #00ffff;
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
            max-width: 400px;
            width: 90%;
        }

        /* Start Menu Controls */
        .menu-btn {
            background: #2b1055;
            border: 2px solid #00ffff;
            color: #00ffff;
            font-family: inherit;
            padding: 15px;
            cursor: pointer;
            width: 100%;
            margin-top: 15px;
            font-size: 18px;
            text-shadow: 0 0 5px #00ffff;
            transition: all 0.2s;
            text-transform: uppercase;
            font-weight: bold;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,255,255,0.2);
        }
        .menu-btn:hover { background: #00ffff; color: #000; transform: scale(1.05); }
        .menu-btn:active { transform: translateY(2px); }
        
        #btn-resume, #btn-continue, #btn-save { display: none; }
        
        #btn-continue { border-color: #ffd700; color: #ffd700; }
        #btn-continue:hover { background: #ffd700; color: #000; }

        #btn-save { border-color: #00ff00; color: #00ff00; }
        #btn-save:hover { background: #00ff00; color: #000; }

        #btn-resume { border-color: #fff; color: #fff; }
        #btn-resume:hover { background: #fff; color: #000; }
        
        /* AI Analyze Button */
        #btn-analyze {
            background: linear-gradient(90deg, #7b1fa2, #4a148c);
            border: 2px solid #e040fb;
            color: #fff;
            font-size: 12px;
            padding: 5px 10px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            border-radius: 4px;
            margin-left: 10px;
        }
        #btn-analyze:hover { background: #e040fb; color: #000; }

        .control-group { margin-bottom: 15px; text-align: left; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 14px; color: #00ffff; font-weight: bold; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #00ffff; height: 8px; }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0.8;
            z-index: 2;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
            box-shadow: 0 0 4px #000;
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-family: monospace;
            font-size: 24px;
            background: #000;
            padding: 20px;
            z-index: 20;
            border: 2px solid #ff00ff;
            border-radius: 10px;
            display: none; /* Hidden by default until generation starts */
        }

        /* Hotbar Styles */
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px;
            border-radius: 10px;
            border: 2px solid #555;
            pointer-events: none; 
            z-index: 25;
        }
        .slot {
            width: 50px;
            height: 50px;
            border: 2px solid #333;
            margin: 0 4px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            font-size: 10px;
            color: #fff;
            font-family: monospace;
            background-size: cover;
            background-position: center;
            image-rendering: pixelated;
            pointer-events: auto; 
            border-radius: 4px;
            background-color: rgba(0,0,0,0.5);
            text-shadow: 1px 1px 0 #000;
            position: relative;
        }
        .slot.active {
            border-color: #00ffff;
            transform: scale(1.1);
            background-color: rgba(0,255,255,0.2);
            box-shadow: 0 0 8px #00ffff;
            color: #fff;
        }
        .slot-num {
            position: absolute;
            top: 2px;
            left: 3px;
            font-weight: bold;
            font-size: 12px;
            color: #00ffff;
        }
        .slot-name {
            background: rgba(0,0,0,0.6);
            width: 100%;
            text-align: center;
            padding: 1px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* GAMING REWARD OVERLAY */
        #message-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            animation: fadeIn 0.2s ease-out forwards;
            overflow: hidden;
            padding: 20px;
            box-sizing: border-box;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        
        /* Message Content Styles */
        #message-content-container {
            max-width: 600px;
            width: 90%;
            max-height: 70vh;
            overflow-y: auto;
            background: linear-gradient(180deg, rgba(20, 20, 30, 0.95), rgba(40, 10, 60, 0.95));
            padding: 20px;
            border: 4px solid #ffd700; 
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            position: relative;
        }
        
        #message-content-container::before {
            content: 'LOOT ACQUIRED';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            color: #ffd700;
            padding: 0 15px;
            font-family: 'Verdana', sans-serif;
            font-weight: bold;
            font-size: 16px;
            border: 2px solid #ffd700;
            border-radius: 20px;
        }

        #item-name {
            color: #00ffff; 
            font-family: 'Verdana', sans-serif;
            font-size: 2em;
            text-align: center;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 20px;
            margin-top: 10px;
            text-transform: uppercase;
            font-weight: 900;
        }

        .stat-block {
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            text-align: left;
            border-top: 1px solid #555;
            padding-top: 15px;
            line-height: 1.6;
        }
        .stat-row { display: flex; justify-content: space-between; }
        .stat-val { color: #ff00ff; font-weight: bold; }

        #message-close {
            margin-top: 20px;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            color: #fff;
            border: none;
            padding: 12px 40px;
            font-size: 18px;
            cursor: pointer;
            font-family: 'Verdana', sans-serif;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.2s;
            border-radius: 30px;
            box-shadow: 0 0 15px rgba(255,0,255,0.5);
        }
        #message-close:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0,255,255,0.7);
        }

        /* Toast Message */
        #toast {
            visibility: hidden;
            min-width: 250px;
            margin-left: -125px;
            background: rgba(0,0,0,0.8);
            color: #fff;
            text-align: center;
            border-radius: 50px;
            border: 2px solid #00ff00;
            padding: 16px;
            position: fixed;
            z-index: 2000;
            left: 50%;
            bottom: 120px; 
            font-size: 16px;
            font-family: 'Verdana', sans-serif;
            font-weight: bold;
            box-shadow: 0 0 15px #00ff00;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.2s, transform 0.2s;
        }

        #toast.show {
            visibility: visible;
            opacity: 1;
            transform: translateY(0);
        }

        /* XP Orbs */
        .xp-orb {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: radial-gradient(circle, #ccff00, #00ff00);
            box-shadow: 0 0 10px #00ff00;
            pointer-events: none;
            z-index: 101;
            top: 50%;
            left: 50%;
            animation: orbScatter 1.5s ease-out forwards;
        }
        @keyframes orbScatter {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        /* Break Particles */
        .break-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #fff;
            pointer-events: none;
            z-index: 101;
            top: 50%; left: 50%;
            animation: breakScatter 0.5s ease-out forwards;
        }
        @keyframes breakScatter {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        /* Fireworks */
        .firework {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            animation: shoot 1s ease-out forwards;
            z-index: 99;
        }
        .rocket {
            position: absolute;
            width: 8px;
            height: 25px;
            background: #fff;
            border: 1px solid #000;
            z-index: 200;
            animation: shootRocket 1s ease-out forwards;
        }
        @keyframes shootRocket {
            0% { transform: translate(-50%, 100vh); opacity: 1; }
            100% { transform: translate(-50%, var(--fy)); opacity: 0; }
        }
        @keyframes shoot {
            0% { transform: translateY(100vh) scale(1); opacity: 1; }
            50% { opacity: 1; }
            100% { transform: translateY(var(--fy)) scale(0); opacity: 0; }
        }
        .spark {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: sparkle 1.5s ease-out forwards;
        }
        @keyframes sparkle {
            0% { transform: translate(0, 0); opacity: 1; }
            100% { transform: translate(var(--sx), var(--sy)); opacity: 0; }
        }

        @keyframes explode {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            10% { opacity: 1; }
            100% { transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) rotate(var(--rot)); opacity: 0; }
        }

        /* Heart Sparks for Finale */
        .heart-spark {
            position: absolute;
            font-size: 24px;
            animation: heartDrift 3s ease-out forwards;
            pointer-events: none;
            z-index: 200;
            text-shadow: 0 0 10px #ff1493;
        }
        @keyframes heartDrift {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            10% { opacity: 1; }
            100% { transform: translate(calc(-50% + var(--ex)), calc(-50% + var(--ey))) scale(1.2); opacity: 0; }
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        /* Cherry Blossom Petals */
        .sakura-petal {
            position: absolute;
            top: -20px;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, #ffb7c5 0%, #ffc0cb 100%);
            border-radius: 100% 0 100% 0;
            pointer-events: none;
            z-index: 98;
            animation: fallRotate 6s linear forwards;
        }
        @keyframes fallRotate {
            0% { transform: translate(0, 0) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            100% { transform: translate(-100px, 100vh) rotate(720deg); opacity: 0; }
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }
        @media (max-width: 1024px) {
            #mobile-controls { display: block; }
            #blocker { display: none !important; }
            #hotbar { bottom: 10px; transform: translateX(-50%) scale(0.9); }
            #health-container { bottom: 70px; width: 200px; }
        }

        /* Joystick Styles */
        #joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: 50%;
            pointer-events: auto;
            z-index: 30;
            touch-action: none;
        }
        #joystick-knob {
            position: absolute;
            top: 50%; left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 15px #00ffff;
        }

        .action-grp {
            position: absolute;
            bottom: 60px;
            right: 20px;
            width: 160px;
            height: 160px;
            pointer-events: auto;
            z-index: 30;
        }
        .action-btn {
            position: absolute;
            width: 65px;
            height: 65px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ffff;
            color: #00ffff;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
            user-select: none;
            box-shadow: 0 0 10px rgba(0,255,255,0.3);
            text-transform: uppercase;
        }
        .action-btn:active { background: #00ffff; color: #000; transform: scale(0.95); }
        .btn-jump { bottom: 0; right: 50px; }
        .btn-mine { top: 10px; left: 0; border-color: #ff3333; color: #ff3333; }
        .btn-build { top: 10px; right: 0; border-color: #33ff33; color: #33ff33; }
        .btn-inv { top: 80px; right: 50px; border-color: #ffd700; color: #ffd700; width: 50px; height: 50px; }
        
        #touch-look-zone {
            position: absolute;
            top: 0; right: 0;
            width: 50%;
            height: 80%; 
            z-index: 10;
            pointer-events: auto;
        }
    </style>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load PointerLockControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <!-- Simplex Noise -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>
    <div id="loading">Generating World...</div>
    
    <div id="minimap-container">
        <canvas id="minimap" width="150" height="150"></canvas>
    </div>

    <div id="guide-container">
        <div id="guide-arrow">⬆</div>
        <div id="guide-text">Quest: Secure the Loot</div>
        <div id="chase-warning">⚠ GLITCH DETECTED ⚠</div>
    </div>

    <div id="health-container">
        <div id="health-bar"></div>
        <div id="health-text">HP: 100%</div>
    </div>

    <div id="ai-message-area">SYSTEM: Initializing...</div>

    <div id="inventory-screen">
        <div class="inv-header">
            <span>INVENTORY</span>
            <div>
                 <button id="btn-analyze" onclick="analyzeStatus()">✨ ANALYZE</button>
                 <span style="font-size:14px; cursor:pointer; margin-left:10px;" onclick="toggleInventory()">[X] CLOSE</span>
            </div>
        </div>
        <div class="inv-grid" id="inv-grid-content">
            <!-- Items injected via JS -->
        </div>
        <div style="margin-top:20px; font-size:12px; color:#aaa;">
            Click item to equip. Metal blocks prevent zombies from entering.
        </div>
    </div>

    <div id="message-overlay">
        <div id="message-content-container">
            <div id="item-name">ITEM NAME</div>
            <div class="stat-block" id="dynamic-content">
                <!-- Content will be injected here -->
            </div>
        </div>
        <button id="message-close">Equip & Continue</button>
    </div>

    <!-- Toast Notification -->
    <div id="toast">Checkpoint Reached!</div>

    <div id="blocker">
        <div id="instructions">
            <h1 style="color:#00ffff; text-shadow:0 0 10px #00ffff; margin-bottom: 20px;">Mini Minecraft</h1>
            
            <div class="control-group">
                <label>Tree Density</label>
                <input type="range" id="treeDensity" min="0" max="100" value="30">
            </div>
            <div class="control-group">
                <label>Water Level</label>
                <input type="range" id="waterLevel" min="0" max="6" value="2" step="0.5">
            </div>
            <div class="control-group">
                <label>Hill Height</label>
                <input type="range" id="terrainRoughness" min="2" max="12" value="4">
            </div>

            <button id="btn-continue" class="menu-btn" style="display:none;">CONTINUE</button>
            <button id="btn-start" class="menu-btn">NEW GAME</button>
            
            <button id="btn-resume" class="menu-btn">RESUME</button>
            <button id="btn-save" class="menu-btn">SAVE GAME</button>
            
            <div style="margin-top:20px; font-size:14px; color:#aaa;">
                Find 6 Crates. Survive The Glitch.<br>
                Safe House: Blue Zone on Map<br>
                Press 'E' for Inventory
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <div id="crosshair"></div>
    
    <div id="ui">
        <h2>Mini Minecraft</h2>
        <p>FPS: 60 | PING: 0ms</p>
    </div>

    <div id="hotbar"></div>

    <!-- Mobile Controls Overlay -->
    <div id="mobile-controls">
        <div id="joystick-zone">
            <div id="joystick-knob"></div>
        </div>
        <div class="action-grp">
            <div class="action-btn btn-mine" id="btn-mobile-mine">Mine</div>
            <div class="action-btn btn-build" id="btn-mobile-build">Place</div>
            <div class="action-btn btn-jump" id="btn-mobile-jump">JUMP</div>
            <div class="action-btn btn-inv" id="btn-mobile-inv">BAG</div>
        </div>
        <div id="touch-look-zone"></div>
    </div>

    <script>
        const apiKey = ""; // API Key injected by environment
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 1024;
        
        // Define sequence of treasure boxes (Increased to 6)
        let TREASURES = [
            { id: 1, x: 0, z: 0, found: false },
            { id: 2, x: 0, z: 0, found: false },
            { id: 3, x: 0, z: 0, found: false },
            { id: 4, x: 0, z: 0, found: false },
            { id: 5, x: 0, z: 0, found: false },
            { id: 6, x: 0, z: 0, found: false }
        ];
        
        let playerHP = 100;
        let lastDamageTime = 0;
        let speedBoostActive = false;
        let isDead = false;
        const START_POS = { x: 0, z: 0 };
        const VILLAGE_POS = { x: 30, y: 10, z: 0 };

        // --- GEMINI AI INTEGRATION ---
        async function callGemini(prompt) {
            if (!apiKey) {
                console.warn("No API Key");
                return "System Offline. (No API Key)";
            }
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "System Error.";
            } catch (e) {
                console.error(e);
                return "Connection Lost.";
            }
        }

        async function showAIMessage(text) {
            const area = document.getElementById('ai-message-area');
            area.innerText = "SYSTEM: " + text;
            area.style.display = 'block';
            
            // Re-trigger animation
            area.style.animation = 'none';
            area.offsetHeight; /* trigger reflow */
            area.style.animation = 'slideIn 0.5s ease-out';
            
            setTimeout(() => {
                area.style.display = 'none';
            }, 8000);
        }

        async function analyzeStatus() {
             const btn = document.getElementById('btn-analyze');
             btn.innerText = "Scanning...";
             const heldItem = blockTypes[selectedBlockIndex].name;
             const foundCount = TREASURES.filter(t => t.found).length;
             
             const prompt = `You are a survival AI in a glitchy digital world. 
             The player has ${playerHP}% Health.
             They are holding: ${heldItem}.
             They have found ${foundCount}/6 treasures.
             Give a short, cryptic, 1-sentence survival tip based on this status. Do not use hashtags.`;
             
             const tip = await callGemini(prompt);
             btn.innerText = "✨ ANALYZE";
             alert(tip); // Simple alert for inventory screen context
        }

        // --- 1. Texture Generation System ---
        const canvasSize = 64; 
        
        function createTexture(drawFn) {
            const canvas = document.createElement('canvas');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            drawFn(ctx, canvasSize);
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            return tex;
        }

        function drawNoise(ctx, w, h, baseColor, noiseColor, density) {
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = noiseColor;
            const pixelSize = w / 16; 
            for(let y=0; y<16; y++) {
                for(let x=0; x<16; x++) {
                    if(Math.random() < density) {
                        ctx.fillRect(x*pixelSize, y*pixelSize, pixelSize, pixelSize);
                    }
                }
            }
        }

        const textures = {
            grassTop: createTexture((ctx, s) => { drawNoise(ctx, s, s, '#4caf50', '#2e7d32', 0.4); }), 
            dirt: createTexture((ctx, s) => { drawNoise(ctx, s, s, '#795548', '#4e342e', 0.3); }),
            path: createTexture((ctx, s) => { 
                drawNoise(ctx, s, s, '#9e9e9e', '#616161', 0.2); 
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(s/4, s/4, s/2, s/2);
            }), 
            grassSide: createTexture((ctx, s) => {
                drawNoise(ctx, s, s, '#795548', '#4e342e', 0.3);
                ctx.fillStyle = '#4caf50';
                ctx.fillRect(0, 0, s, s/4);
            }),
            logSide: createTexture((ctx, s) => { drawNoise(ctx, s, s, '#5d4037', '#3e2723', 0.6); }),
            logTop: createTexture((ctx, s) => {
                drawNoise(ctx, s, s, '#795548', '#5d4037', 0.2);
                ctx.strokeStyle = '#3e2723';
                ctx.lineWidth = s/8;
                ctx.beginPath();
                ctx.arc(s/2, s/2, s/3, 0, Math.PI*2);
                ctx.stroke();
            }),
            leaves: createTexture((ctx, s) => {
                drawNoise(ctx, s, s, '#66bb6a', '#388e3c', 0.5); 
                const pixel = s/16;
                ctx.fillStyle = '#1b5e20';
                for(let i=0; i<10; i++) { ctx.fillRect(Math.random()*s, Math.random()*s, pixel, pixel); }
            }),
            water: createTexture((ctx, s) => {
                ctx.fillStyle = '#0288d1'; 
                ctx.fillRect(0,0,s,s);
                ctx.fillStyle = '#29b6f6';
                const pixel = s/16;
                for(let i=0; i<10; i++) { ctx.fillRect(Math.random()*s, Math.random()*s, pixel*2, pixel); }
            }),
            chest: createTexture((ctx, s) => {
                drawNoise(ctx, s, s, '#ffa000', '#ff6f00', 0.3);
                ctx.fillStyle = '#000';
                ctx.fillRect(s/2-2, s/2-4, 4, 8); 
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(2,2,s-4,s-4);
            }),
            skin: createTexture((ctx, s) => { ctx.fillStyle = '#ffcc80'; ctx.fillRect(0,0,s,s); }),
            diamond: createTexture((ctx, s) => { ctx.fillStyle = '#00e5ff'; ctx.fillRect(0,0,s,s); ctx.fillStyle='rgba(255,255,255,0.5)'; ctx.fillRect(4,4,8,8); }),
            iron: createTexture((ctx, s) => { ctx.fillStyle = '#e0e0e0'; ctx.fillRect(0,0,s,s); }),
            obsidian: createTexture((ctx, s) => { ctx.fillStyle = '#311b92'; ctx.fillRect(0,0,s,s); }),
            slime: createTexture((ctx, s) => { ctx.fillStyle = '#76ff03'; ctx.fillRect(0,0,s,s); ctx.fillStyle = '#000'; ctx.fillRect(s/4, s/3, s/8, s/8); ctx.fillRect(s*0.75-s/8, s/3, s/8, s/8); }), 
            
            // Flower Textures
            flowerRed: createTexture((ctx, s) => {
                ctx.clearRect(0,0,s,s);
                ctx.fillStyle = '#2e7d32'; ctx.fillRect(s/2-2, s/2, 4, s/2); 
                ctx.fillStyle = '#ff1744'; 
                ctx.fillRect(s/2-6, s/2-12, 12, 12); ctx.fillRect(s/2-10, s/2-8, 4, 4);
                ctx.fillRect(s/2+6, s/2-8, 4, 4); ctx.fillRect(s/2-2, s/2-16, 4, 4);
                ctx.fillStyle = '#ffeb3b'; ctx.fillRect(s/2-2, s/2-8, 4, 4); 
            }),
            flowerYellow: createTexture((ctx, s) => {
                ctx.clearRect(0,0,s,s);
                ctx.fillStyle = '#2e7d32'; ctx.fillRect(s/2-2, s/2, 4, s/2);
                ctx.fillStyle = '#ffea00'; 
                ctx.fillRect(s/2-6, s/2-12, 12, 12); ctx.fillRect(s/2-10, s/2-8, 4, 4);
                ctx.fillRect(s/2+6, s/2-8, 4, 4); ctx.fillRect(s/2-2, s/2-16, 4, 4);
                ctx.fillStyle = '#ff6d00'; ctx.fillRect(s/2-2, s/2-8, 4, 4);
            }),
            flowerBlue: createTexture((ctx, s) => {
                ctx.clearRect(0,0,s,s);
                ctx.fillStyle = '#2e7d32'; ctx.fillRect(s/2-2, s/2, 4, s/2);
                ctx.fillStyle = '#2979ff'; 
                ctx.fillRect(s/2-6, s/2-12, 12, 12); ctx.fillRect(s/2-10, s/2-8, 4, 4);
                ctx.fillRect(s/2+6, s/2-8, 4, 4); ctx.fillRect(s/2-2, s/2-16, 4, 4);
                ctx.fillStyle = '#ffffff'; ctx.fillRect(s/2-2, s/2-8, 4, 4);
            }),
            
            // New Metal Texture
            metal: createTexture((ctx, s) => {
                drawNoise(ctx, s, s, '#708090', '#2f4f4f', 0.4);
                ctx.strokeStyle = '#4a4a4a';
                ctx.lineWidth = 2;
                ctx.strokeRect(0,0,s,s);
                ctx.beginPath();
                ctx.moveTo(0,0); ctx.lineTo(s,s);
                ctx.moveTo(s,0); ctx.lineTo(0,s);
                ctx.stroke();
                ctx.fillStyle = 'rgba(200,200,200,0.2)';
                ctx.fillRect(4,4,8,8);
            }),
            // New Stone Texture (Rock)
            stone: createTexture((ctx, s) => {
                ctx.fillStyle = '#7a7a7a'; ctx.fillRect(0,0,s,s);
                ctx.fillStyle = '#525252';
                for(let i=0; i<20; i++) ctx.fillRect(Math.random()*s, Math.random()*s, s/8, s/8);
            }),
            // Inventory Icon Texture
            inventory: createTexture((ctx, s) => {
                ctx.fillStyle = '#8d6e63'; ctx.fillRect(0,0,s,s);
                ctx.fillStyle = '#5d4037'; ctx.fillRect(s/4, s/4, s/2, s/2);
                ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.strokeRect(s/3, s/3, s/3, s/3);
            }),
            // New Sand Texture
            sand: createTexture((ctx, s) => {
                ctx.fillStyle = '#e6ddc5'; ctx.fillRect(0,0,s,s);
                ctx.fillStyle = '#d1c7a7';
                for(let i=0; i<20; i++) ctx.fillRect(Math.random()*s, Math.random()*s, s/16, s/16);
            }),
            // New Snow Texture
            snow: createTexture((ctx, s) => {
                ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,s,s);
                ctx.fillStyle = '#e0f7fa';
                for(let i=0; i<10; i++) ctx.fillRect(Math.random()*s, Math.random()*s, s/8, s/8);
            })
        };

        const materials = {
            grass: [
                new THREE.MeshLambertMaterial({ map: textures.grassSide }), 
                new THREE.MeshLambertMaterial({ map: textures.grassSide }), 
                new THREE.MeshLambertMaterial({ map: textures.grassTop }),  
                new THREE.MeshLambertMaterial({ map: textures.dirt }),      
                new THREE.MeshLambertMaterial({ map: textures.grassSide }), 
                new THREE.MeshLambertMaterial({ map: textures.grassSide })  
            ],
            path: new THREE.MeshLambertMaterial({ map: textures.path }),
            dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }),
            log: new THREE.MeshLambertMaterial({ map: textures.logSide }),
            leaves: new THREE.MeshLambertMaterial({ map: textures.leaves, transparent: true, opacity: 0.95 }),
            water: new THREE.MeshLambertMaterial({ map: textures.water, transparent: true, opacity: 0.8 }),
            chest: new THREE.MeshLambertMaterial({ map: textures.chest }),
            skin: new THREE.MeshLambertMaterial({ map: textures.skin }),
            diamond: new THREE.MeshLambertMaterial({ map: textures.diamond }),
            iron: new THREE.MeshLambertMaterial({ map: textures.iron }),
            obsidian: new THREE.MeshLambertMaterial({ map: textures.obsidian }),
            slime: new THREE.MeshLambertMaterial({ map: textures.slime, transparent: true, opacity: 0.8 }),
            flowerRed: new THREE.MeshLambertMaterial({ map: textures.flowerRed, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide }),
            flowerYellow: new THREE.MeshLambertMaterial({ map: textures.flowerYellow, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide }),
            flowerBlue: new THREE.MeshLambertMaterial({ map: textures.flowerBlue, transparent: true, alphaTest: 0.5, side: THREE.DoubleSide }),
            metal: new THREE.MeshLambertMaterial({ map: textures.metal }),
            stone: new THREE.MeshLambertMaterial({ map: textures.stone }),
            sand: new THREE.MeshLambertMaterial({ map: textures.sand }),
            snow: new THREE.MeshLambertMaterial({ map: textures.snow })
        };

        // --- 2. Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 20, 110); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.9); 
        sunLight.position.set(50, 80, 30);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        sunLight.shadow.bias = -0.001;
        scene.add(sunLight);

        // Add Clouds
        function createCloud() {
            const cloudGeo = new THREE.BoxGeometry(4, 2, 4);
            const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            const cloud = new THREE.Mesh(cloudGeo, cloudMat);
            cloud.position.set((Math.random() - 0.5) * 200, 40 + Math.random() * 10, (Math.random() - 0.5) * 200);
            scene.add(cloud);
            // Animate cloud
            setInterval(() => {
                cloud.position.x += 0.05;
                if(cloud.position.x > 100) cloud.position.x = -100;
            }, 50);
        }
        for(let i=0; i<15; i++) createCloud();


        // --- 3. World Generation ---
        const CHUNK_SIZE = 180; // Increased World Size
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        
        // Flower Geometry
        const flowerGeometry = new THREE.BufferGeometry();
        const fVerts = []; const fUVs = []; const fNormals = [];
        // Plane 1
        fVerts.push(-0.35, 0.8, 0,  0.35, 0.8, 0,  -0.35, 0.0, 0,  -0.35, 0.0, 0,  0.35, 0.8, 0,  0.35, 0.0, 0);
        fUVs.push(0,1, 1,1, 0,0, 0,0, 1,1, 1,0);
        for(let i=0;i<6;i++) fNormals.push(0,0,1);
        // Plane 2
        fVerts.push(0, 0.8, -0.35,  0, 0.8, 0.35,  0, 0.0, -0.35,  0, 0.0, -0.35,  0, 0.8, 0.35,  0, 0.0, 0.35);
        fUVs.push(0,1, 1,1, 0,0, 0,0, 1,1, 1,0);
        for(let i=0;i<6;i++) fNormals.push(1,0,0);
        flowerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(fVerts, 3));
        flowerGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(fUVs, 2));
        flowerGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(fNormals, 3));

        // --- SEEDED RANDOM ---
        let gameSeed = Date.now();
        let seedPointer = 0;
        function seededRandom() {
            const x = Math.sin(gameSeed + (seedPointer++)) * 10000;
            return x - Math.floor(x);
        }

        const simplex = new SimplexNoise(seededRandom);
        
        let instances = { grass: [], path: [], dirt: [], log: [], leaves: [], water: [], chest: [], flowerRed: [], flowerYellow: [], flowerBlue: [], metal: [], stone: [], sand: [], snow: [] };
        let meshes = {};
        let worldBlocks = new Map(); 
        let waterBlocks = new Set();
        let placedBlocks = [];
        let interactableObjects = []; 
        let mobs = [];

        function addBlock(type, x, y, z) {
            const matrix = new THREE.Matrix4();
            matrix.setPosition(x, y, z);
            if (instances[type]) {
                instances[type].push(matrix);
            }
            if (type === 'water') {
                waterBlocks.add(`${x},${y},${z}`);
            } else if (!type.includes('flower')) { 
                worldBlocks.set(`${x},${y},${z}`, type);
            }
        }

        // --- HAND ITEM SYSTEM ---
        const handGroup = new THREE.Group();
        camera.add(handGroup);
        // Adjusted POV - Default Position/Rotation
        const HAND_DEF_POS = { x: 0.6, y: -0.5, z: -0.8 };
        const HAND_DEF_ROT = { x: 0.2, y: -0.1, z: 0 };
        
        handGroup.position.set(HAND_DEF_POS.x, HAND_DEF_POS.y, HAND_DEF_POS.z);
        handGroup.rotation.set(HAND_DEF_ROT.x, HAND_DEF_ROT.y, HAND_DEF_ROT.z);
        
        // Base Hand
        const armGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
        const armMesh = new THREE.Mesh(armGeo, materials.skin);
        armMesh.position.y = -0.2;
        handGroup.add(armMesh);

        function equipItem(itemName) {
            // Remove old items (except arm)
            for(let i = handGroup.children.length - 1; i >= 0; i--) {
                if(handGroup.children[i] !== armMesh) handGroup.remove(handGroup.children[i]);
            }

            if (itemName === 'sword') {
                const swordGroup = new THREE.Group();
                swordGroup.userData.isSword = true; // Add this
                const handle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.3, 0.05), new THREE.MeshLambertMaterial({color: 0x5d4037}));
                handle.position.y = 0.15; swordGroup.add(handle);
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.05, 0.05), materials.diamond);
                guard.position.y = 0.3; swordGroup.add(guard);
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.02), materials.diamond);
                blade.position.y = 0.7; swordGroup.add(blade);
                swordGroup.position.set(0, 0.2, -0.1); swordGroup.rotation.x = -Math.PI / 4;
                handGroup.add(swordGroup);
            }
            else if (itemName === 'hammer') {
                const hammerGroup = new THREE.Group();
                const handle = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.6, 0.06), new THREE.MeshLambertMaterial({color: 0x3e2723}));
                handle.position.y = 0.3; hammerGroup.add(handle);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.2), materials.obsidian);
                head.position.y = 0.6; hammerGroup.add(head);
                hammerGroup.position.set(0, 0.2, -0.1); hammerGroup.rotation.x = -Math.PI / 4;
                handGroup.add(hammerGroup);
            }
            else if (itemName === 'shield') {
                const shieldGroup = new THREE.Group();
                // Handle
                const handle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 0.05), new THREE.MeshLambertMaterial({color: 0x5d4037}));
                handle.rotation.x = Math.PI / 2;
                shieldGroup.add(handle);
                
                // Shield Body
                const plate = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.1), new THREE.MeshPhongMaterial({color: 0x00ffff, transparent: true, opacity: 0.6}));
                plate.position.z = 0.1;
                shieldGroup.add(plate);
                
                // Emissive border
                const border = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.85, 0.05), new THREE.MeshBasicMaterial({color: 0x00ffff}));
                border.position.z = 0.1;
                shieldGroup.add(border);

                shieldGroup.userData.isShield = true;
                shieldGroup.position.set(0, 0, -0.2); 
                shieldGroup.rotation.y = Math.PI / 4;
                handGroup.add(shieldGroup);
            }
        }

        scene.add(camera);

        // --- TREASURE & MOBS SPAWNING ---
        function spawnTreasureBox(id, x, y, z) {
            const boxGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const box = new THREE.Mesh(boxGeo, materials.chest);
            box.position.set(x, y, z);
            box.castShadow = true; box.receiveShadow = true;
            box.userData = { isTreasure: true, treasureId: id };
            scene.add(box);
            interactableObjects.push(box);
            worldBlocks.set(`${x},${y},${z}`, 'chest'); 
        }

        function generateTree(x, y, z) {
            const height = 4 + Math.floor(seededRandom() * 3);
            for(let i=0; i<height; i++) addBlock('log', x, y+i, z);
            const radius = 2;
            for(let lx = -radius; lx <= radius; lx++) {
                for(let ly = -radius; ly <= radius; ly++) {
                    for(let lz = -radius; lz <= radius; lz++) {
                        const dist = lx*lx + ly*ly + lz*lz;
                        if (dist < radius*radius + seededRandom()) {
                            if (lx===0 && lz===0 && ly < height-2) continue; 
                            addBlock('leaves', x+lx, y+height-1+ly, z+lz);
                        }
                    }
                }
            }
        }

        let worldGenerated = false;

        function generateWorld(keepExisting = false, loadData = null) {
            document.getElementById('loading').style.display = 'block';

            setTimeout(() => {
                const density = parseInt(document.getElementById('treeDensity').value) / 100;
                const waterLvl = parseFloat(document.getElementById('waterLevel').value);
                const roughness = parseInt(document.getElementById('terrainRoughness').value);

                if (!keepExisting) {
                    // RESET
                    Object.keys(meshes).forEach(key => { if (meshes[key]) { scene.remove(meshes[key]); meshes[key].geometry.dispose(); } });
                    meshes = {}; 
                    Object.keys(instances).forEach(key => instances[key] = []);
                    worldBlocks.clear();
                    waterBlocks.clear();
                    placedBlocks.forEach(mesh => scene.remove(mesh));
                    placedBlocks = [];
                    interactableObjects.forEach(obj => scene.remove(obj));
                    interactableObjects = [];
                    mobs.forEach(m => scene.remove(m));
                    mobs = [];
                    
                    if (villains.length > 0) villains.forEach(v => scene.remove(v));
                    villains = [];
                    if (safeHouseGroup) { scene.remove(safeHouseGroup); safeHouseGroup = null; }

                    // LOAD OR NEW SEED
                    if (loadData) {
                        gameSeed = loadData.seed;
                        TREASURES = loadData.treasures;
                        camera.position.set(loadData.pos.x, loadData.pos.y, loadData.pos.z);
                        camera.rotation.set(loadData.rot.x, loadData.rot.y, loadData.rot.z);
                        selectedBlockIndex = loadData.inventory;
                        playerHP = loadData.hp || 100;
                        updateHealthUI();
                        
                        spawnVillains(0, loadData.villains); // Load saved villains
                    } else {
                        gameSeed = Date.now();
                        playerHP = 100;
                        updateHealthUI();
                        isDead = false;
                        // Reset Treasures (Now 6)
                        const newLootLocs = [];
                        seedPointer = 0; // Temp reset for loop
                        while(newLootLocs.length < 6) {
                            const lx = Math.floor(seededRandom() * 80) - 40; 
                            const lz = Math.floor(seededRandom() * 80) - 40;
                            if(Math.abs(lx) > 5 || Math.abs(lz) > 5) newLootLocs.push({x: lx, z: lz});
                        }
                        TREASURES.forEach((t, i) => {
                            t.x = newLootLocs[i].x; t.z = newLootLocs[i].z; t.found = false;
                        });
                        resetPlayerPosition();
                        spawnVillains(3); // Spawn 3 new villains

                        // --- NEW AI FEATURE: Generate World Intro ---
                        // Only generate this once per new game
                        setTimeout(async () => {
                             const intro = await callGemini("Write a 1-sentence scary sci-fi welcome message for a player entering 'The Grind: 2026', a digital wasteland.");
                             showAIMessage(intro);
                        }, 1000);
                    }

                    seedPointer = 0; // Reset RNG for consistency

                    for(let x = -CHUNK_SIZE/2; x < CHUNK_SIZE/2; x++) {
                        for(let z = -CHUNK_SIZE/2; z < CHUNK_SIZE/2; z++) {
                            let value = simplex.noise2D(x * 0.04, z * 0.04);
                            let height = Math.floor(value * roughness) + 5;
                            
                            const onPath = (Math.abs(x - z) < 3 && x > -5 && x < 55); 
                            const isFlowerField = (Math.abs(x - 50) < 15 && Math.abs(z - 50) < 15);
                            // New: Check Village Area
                            const isVillage = (Math.abs(x - VILLAGE_POS.x) < 18 && Math.abs(z - VILLAGE_POS.z) < 18);

                            if (onPath || isFlowerField || isVillage) {
                                height = Math.max(height, Math.ceil(waterLvl) + 1);
                                if (isFlowerField || isVillage) value = 0; 
                            }

                            // Check for random loot spot
                            const lootIdx = TREASURES.findIndex(t => !t.found && t.x === Math.round(x) && t.z === Math.round(z));
                            if (lootIdx !== -1) {
                                 spawnTreasureBox(TREASURES[lootIdx].id, x, height + 1, z);
                            }
                            
                            // Height-Based Biome Logic
                            if (height < waterLvl) {
                                // Under Water
                                addBlock('dirt', x, height, z);
                                for(let w = height + 1; w <= waterLvl; w++) { addBlock('water', x, w, z); }
                            } else {
                                // Land
                                let blockType = 'grass';
                                
                                if (onPath) blockType = 'path';
                                else if (isVillage) blockType = 'dirt';
                                else {
                                    if (height <= waterLvl + 1) blockType = 'sand'; // Beach
                                    else if (height > waterLvl + 6) blockType = 'stone'; // Mountain
                                    if (height > waterLvl + 9) blockType = 'snow'; // Peak
                                }

                                addBlock(blockType, x, height, z);

                                // Vegetation only on grass
                                if (blockType === 'grass' && !isFlowerField && !isVillage) {
                                    if (seededRandom() < density && Math.abs(x) > 2 && Math.abs(z) > 2) {
                                        generateTree(x, height + 1, z);
                                    }
                                }
                                
                                // Flowers
                                if (isFlowerField && blockType === 'grass') {
                                    if (seededRandom() > 0.1 && !(Math.round(x) === 50 && Math.round(z) === 50)) { 
                                        const fType = ['flowerRed', 'flowerYellow', 'flowerBlue'][Math.floor(seededRandom()*3)];
                                        addBlock(fType, x, height + 0.5, z);
                                    }
                                }
                                
                                // Rocks/Boulders (World Expansion)
                                if (blockType === 'grass' || blockType === 'stone') {
                                   if (seededRandom() < 0.015) { // 1.5% chance
                                       addBlock('stone', x, height + 1, z);
                                       if(seededRandom() < 0.3) addBlock('stone', x, height + 2, z); 
                                   }
                                }
                            }
                            for(let d = -4; d < height; d++) addBlock('dirt', x, d, z);
                        }
                    }
                    
                    // Create Village
                    generateVillage(VILLAGE_POS.x, VILLAGE_POS.z);

                    // Create Lake
                    generateLake(-30, -30);

                    // Create Waterfall (Cliff)
                    generateWaterfall(-30, -55);

                    spawnSafeHouse(); 
                } 
                
                Object.keys(instances).forEach(key => {
                    if (meshes[key]) scene.remove(meshes[key]);
                    const arr = instances[key];
                    if (arr.length === 0) return;
                    const geoToUse = key.includes('flower') ? flowerGeometry : geometry;
                    const mesh = new THREE.InstancedMesh(geoToUse, materials[key], arr.length);
                    mesh.castShadow = !key.includes('flower'); 
                    mesh.receiveShadow = true;
                    for(let i=0; i<arr.length; i++) mesh.setMatrixAt(i, arr[i]);
                    mesh.instanceMatrix.needsUpdate = true;
                    scene.add(mesh);
                    meshes[key] = mesh;
                });
                
                worldGenerated = true;
                updateHotbarUI();
                
                // Update UI Buttons
                document.getElementById('btn-start').style.display = 'none';
                document.getElementById('btn-continue').style.display = 'none';
                document.getElementById('btn-resume').style.display = 'block';
                document.getElementById('btn-save').style.display = 'block';
                
                document.getElementById('loading').style.display = 'none';
            }, 50);
        }

        // --- GENERATION HELPERS ---
        function generateVillage(vx, vz) {
            const groundY = Math.ceil(parseFloat(document.getElementById('waterLevel').value) + 1);
            
            // House 1 (Main)
            buildHouse(vx, groundY, vz, 5, 4, 5);
            // House 2
            buildHouse(vx + 8, groundY, vz + 6, 4, 3, 4);
            // House 3
            buildHouse(vx - 8, groundY, vz + 4, 4, 3, 4);
            // House 4
            buildHouse(vx, groundY, vz + 10, 5, 3, 4);
        }

        function buildHouse(bx, by, bz, w, h, d) {
             // Floor
            for(let i=0; i<w; i++) {
                for(let j=0; j<d; j++) {
                    addBlock('dirt', bx+i, by, bz+j); 
                }
            }
            // Walls
            for(let y=1; y<h; y++) {
                for(let i=0; i<w; i++) {
                    for(let j=0; j<d; j++) {
                        if(i===0 || i===w-1 || j===0 || j===d-1) {
                             if(y===2 && (i===Math.floor(w/2) || j===Math.floor(d/2))) continue; // Windows
                             if(y<3 && i===Math.floor(w/2) && j===0) continue; // Door
                             addBlock('log', bx+i, by+y, bz+j);
                        }
                    }
                }
            }
            // Roof
            for(let i=0; i<w; i++) {
                for(let j=0; j<d; j++) {
                    addBlock('dirt', bx+i, by+h, bz+j);
                }
            }
        }

        function generateLake(lx, lz) {
            // Noise function handles it mostly via randomization, but we can ensure clear area
        }

        function generateWaterfall(wx, wz) {
            // Create a wall of water
             for(let y=10; y<30; y++) {
                 for(let x=0; x<4; x++) {
                     addBlock('water', wx+x, y, wz);
                 }
             }
             // Splash pool at bottom
             for(let x=-2; x<6; x++) {
                 for(let z=-2; z<6; z++) {
                     addBlock('water', wx+x, 9, wz+z);
                 }
             }
        }

        // --- 4. Player & Physics ---
        const controls = new THREE.PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        const messageOverlay = document.getElementById('message-overlay');
        const closeMessageBtn = document.getElementById('message-close');

        function updateHealthUI() {
            const bar = document.getElementById('health-bar');
            const txt = document.getElementById('health-text');
            bar.style.width = playerHP + '%';
            txt.innerText = 'HP: ' + playerHP + '%';
        }

        function takeDamage(amount) {
            if (isDead) return;
            playerHP -= amount;
            lastDamageTime = Date.now();
            
            // Visual Flash
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.top = '0'; flash.style.left = '0';
            flash.style.width = '100%'; flash.style.height = '100%';
            flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '50';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 200);

            if (playerHP <= 0) {
                playerHP = 0;
                die();
            }
            updateHealthUI();
        }

        function die() {
            isDead = true;
            playerHP = 0;
            updateHealthUI();
            
            // Remove Save (Permadeath)
            localStorage.removeItem('the_grind_save');
            
            showToast("GAME OVER");
            
            if (isMobile) {
                // Mobile Game Over Logic
                setTimeout(() => location.reload(), 3000); 
            } else {
                setTimeout(() => {
                    controls.unlock(); 
                }, 1000);
            }
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = "show";
            setTimeout(function(){ toast.className = toast.className.replace("show", ""); }, 3000);
        }

        closeMessageBtn.addEventListener('click', () => {
            messageOverlay.style.display = 'none';
            document.querySelectorAll('.xp-orb').forEach(h => h.remove());
            document.querySelectorAll('.firework').forEach(f => f.remove());
            document.querySelectorAll('.spark').forEach(s => s.remove());
            document.querySelectorAll('.rocket').forEach(r => r.remove());
            controls.lock();
            showToast("Loot Secured!");
        });

        // --- SAVE SYSTEM ---
        function saveGame() {
            const villainsData = villains.map(v => ({
                pos: {x: v.position.x, y: v.position.y, z: v.position.z},
                state: v.userData.state,
                roamTarget: v.userData.roamTarget,
                roamTimer: v.userData.roamTimer,
                hp: v.userData.hp // Save HP
            }));

            const saveData = {
                seed: gameSeed,
                pos: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                rot: { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z },
                treasures: TREASURES,
                inventory: selectedBlockIndex,
                villains: villainsData,
                hp: playerHP
            };
            localStorage.setItem('the_grind_save', JSON.stringify(saveData));
            showToast("GAME SAVED!");
        }

        function loadGame() {
            const dataStr = localStorage.getItem('the_grind_save');
            if (dataStr) {
                const data = JSON.parse(dataStr);
                generateWorld(false, data);
                controls.lock();
            } else {
                showToast("No Save Found!");
            }
        }

        if (localStorage.getItem('the_grind_save')) {
            document.getElementById('btn-continue').style.display = 'block';
        }

        document.getElementById('btn-start').addEventListener('click', (e) => {
            if (isDead) {
                location.reload(); // Redirect to new game page (reload app)
            } else {
                generateWorld(false);
                controls.lock();
            }
            e.stopPropagation();
        });

        document.getElementById('btn-continue').addEventListener('click', (e) => {
            loadGame();
            e.stopPropagation();
        });

        document.getElementById('btn-resume').addEventListener('click', (e) => {
            if(worldGenerated) controls.lock();
            e.stopPropagation();
        });

        document.getElementById('btn-save').addEventListener('click', (e) => {
            saveGame();
            e.stopPropagation();
        });
        
        controls.addEventListener('lock', () => blocker.style.display = 'none');
        controls.addEventListener('unlock', () => { 
            if (!isMobile && messageOverlay.style.display === 'none' && document.getElementById('inventory-screen').style.display !== 'flex') {
                blocker.style.display = 'flex'; 
                
                const title = document.querySelector('#instructions h1');
                const btnStart = document.getElementById('btn-start');
                const btnResume = document.getElementById('btn-resume');
                const btnSave = document.getElementById('btn-save');
                const btnContinue = document.getElementById('btn-continue');

                if (isDead) {
                    title.innerText = "GAME OVER";
                    title.style.color = "#ff0000";
                    title.style.textShadow = "0 0 20px #ff0000";
                    
                    btnStart.style.display = 'block';
                    btnStart.innerText = "MAIN MENU"; // Changed from TRY AGAIN
                    
                    btnResume.style.display = 'none';
                    btnSave.style.display = 'none';
                    btnContinue.style.display = 'none';
                } else {
                    title.innerText = "Mini Minecraft";
                    title.style.color = "#00ffff";
                    title.style.textShadow = "0 0 10px #00ffff";

                    btnStart.style.display = 'block';
                    btnStart.innerText = "NEW GAME (RESET)";
                    
                    if (worldGenerated) {
                        btnResume.style.display = 'block';
                        btnSave.style.display = 'block';
                    }
                }
            }
        });

        const player = { velocity: new THREE.Vector3(), direction: new THREE.Vector3(), speed: 60, jumpForce: 15, gravity: 40, canJump: false };
        const moveState = { forward: false, backward: false, left: false, right: false, jump: false };
        const joystickData = { x: 0, y: 0, active: false };

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyE') {
                toggleInventory();
                return;
            }

            // Key '3' now opens Inventory
            if (e.code === 'Digit3') {
                toggleInventory();
                return;
            }

            if (e.code === 'Space' && !controls.isLocked && !isMobile && messageOverlay.style.display === 'none' && document.getElementById('inventory-screen').style.display !== 'flex') {
                if(worldGenerated && !isDead) controls.lock();
                if (document.activeElement) document.activeElement.blur(); 
                e.preventDefault(); 
                return; 
            }

            switch(e.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'Space': moveState.jump = true; break;
                case 'Digit1': selectBlock(0); break;
                case 'Digit2': selectBlock(1); break;
                // Digit 3 is handled above
                case 'Digit4': selectBlock(3); break;
                case 'Digit5': selectBlock(4); break;
                case 'Digit6': selectBlock(5); break;
                case 'Digit7': selectBlock(6); break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyD': moveState.right = false; break;
                case 'Space': moveState.jump = false; break;
            }
        });

        if (isMobile) {
            document.getElementById('blocker').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'block';
            const joyZone = document.getElementById('joystick-zone');
            const joyKnob = document.getElementById('joystick-knob');
            const joyRadius = 35; 
            
            joyZone.addEventListener('touchstart', (e) => {
                e.preventDefault(); joystickData.active = true;
                const rect = joyZone.getBoundingClientRect();
                updateJoystick(e.touches[0].clientX, e.touches[0].clientY, rect.left + rect.width / 2, rect.top + rect.height / 2);
            });
            joyZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = joyZone.getBoundingClientRect();
                updateJoystick(e.touches[0].clientX, e.touches[0].clientY, rect.left + rect.width / 2, rect.top + rect.height / 2);
            });
            joyZone.addEventListener('touchend', (e) => {
                e.preventDefault(); joystickData.active = false; joystickData.x = 0; joystickData.y = 0;
                joyKnob.style.transform = `translate(-50%, -50%)`;
            });
            function updateJoystick(clientX, clientY, centerX, centerY) {
                let dx = clientX - centerX; let dy = clientY - centerY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance > joyRadius) { const ratio = joyRadius / distance; dx *= ratio; dy *= ratio; }
                joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                if (distance > 0) { joystickData.x = (dx / joyRadius); joystickData.y = (dy / joyRadius); }
            }
            const jumpBtn = document.getElementById('btn-mobile-jump');
            jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); moveState.jump = true; jumpBtn.style.backgroundColor = 'rgba(0,255,0,0.4)'; });
            jumpBtn.addEventListener('touchend', (e) => { e.preventDefault(); moveState.jump = false; jumpBtn.style.backgroundColor = 'rgba(0,0,0,0.6)'; });
            
            document.getElementById('btn-mobile-inv').addEventListener('touchstart', (e) => {
                 e.preventDefault(); toggleInventory(); 
            });

            document.getElementById('btn-mobile-mine').addEventListener('touchstart', (e) => { e.preventDefault(); performAction(0); });
            document.getElementById('btn-mobile-build').addEventListener('touchstart', (e) => { e.preventDefault(); performAction(2); });
            const touchZone = document.getElementById('touch-look-zone');
            let lastTouchX = 0; let lastTouchY = 0;
            touchZone.addEventListener('touchstart', (e) => { lastTouchX = e.touches[0].pageX; lastTouchY = e.touches[0].pageY; });
            touchZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const deltaX = e.touches[0].pageX - lastTouchX; const deltaY = e.touches[0].pageY - lastTouchY;
                camera.rotation.y -= deltaX * 0.005; camera.rotation.x -= deltaY * 0.005;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                lastTouchX = e.touches[0].pageX; lastTouchY = e.touches[0].pageY;
            });
            
            // Auto-generate for mobile immediately
            generateWorld(false);
        }

        function resetPlayerPosition() { camera.position.set(0, 10, 0); camera.lookAt(50, 10, 50); player.velocity.set(0, 0, 0); }
        function checkCollision(x, y, z) { return worldBlocks.has(`${Math.round(x)},${Math.round(y)},${Math.round(z)}`); }
        function checkWater(x, y, z) { return waterBlocks.has(`${Math.round(x)},${Math.round(y)},${Math.round(z)}`); }

        function updatePlayer(delta) {
            if ((!controls.isLocked && !isMobile) || document.getElementById('inventory-screen').style.display === 'flex') return;
            let inputZ = Number(moveState.forward) - Number(moveState.backward);
            let inputX = Number(moveState.right) - Number(moveState.left);
            if (joystickData.active) { inputZ = -joystickData.y; inputX = joystickData.x; }

            player.velocity.x -= player.velocity.x * 10.0 * delta;
            player.velocity.z -= player.velocity.z * 10.0 * delta;
            player.velocity.y -= player.gravity * delta;

            // Speed Boost Logic
            const currentSpeed = speedBoostActive ? player.speed * 1.5 : player.speed;

            if (Math.abs(inputZ) > 0.1) player.velocity.z -= inputZ * currentSpeed * delta;
            if (Math.abs(inputX) > 0.1) player.velocity.x -= inputX * currentSpeed * delta;

            if (moveState.jump && player.canJump) { player.velocity.y = player.jumpForce; player.canJump = false; }

            controls.moveRight(-player.velocity.x * delta);
            controls.moveForward(-player.velocity.z * delta);

            if (checkCollision(camera.position.x, camera.position.y - 1.5, camera.position.z)) {
                 controls.moveRight(player.velocity.x * delta);
                 controls.moveForward(player.velocity.z * delta);
            }

            camera.position.y += player.velocity.y * delta;
            const feetY = camera.position.y - 1.6;
            const inWater = checkWater(camera.position.x, feetY, camera.position.z);

            if (inWater) {
                player.gravity = 10; player.speed = 30; // base speed
                if (moveState.jump) player.velocity.y = 10;
                player.canJump = true;
            } else {
                player.gravity = 40; player.speed = 60; // base speed
                if (player.velocity.y <= 0) {
                    if (checkCollision(camera.position.x, feetY - 0.5, camera.position.z)) {
                        player.velocity.y = 0; player.canJump = true;
                        camera.position.y = Math.round(feetY - 0.5) + 0.5 + 1.6;
                    }
                }
            }
            
            if (Math.abs(inputZ) > 0.1 || Math.abs(inputX) > 0.1) {
                handGroup.position.y = -0.4 + Math.sin(Date.now() * 0.015) * 0.05;
                handGroup.rotation.x = Math.sin(Date.now() * 0.015) * 0.1;
            }
            if (camera.position.y < -20) resetPlayerPosition();
        }

        // --- INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0);
        
        const blockTypes = [
            { name: 'Path', material: materials.path, type: 'path' },
            { name: 'Log', material: materials.log, type: 'log' },
            { name: 'Inventory', isInventoryAction: true }, // Special item for Inventory
            { name: 'Planks', material: materials.dirt, type: 'dirt' },
            { name: 'Metal', material: materials.metal, type: 'metal' },
            { name: 'Stone', material: materials.stone, type: 'stone' }
        ];
        let selectedBlockIndex = 0;

        // Inventory Functionality
        function toggleInventory() {
            const inv = document.getElementById('inventory-screen');
            const grid = document.getElementById('inv-grid-content');
            
            if (inv.style.display === 'flex') {
                inv.style.display = 'none';
                if (!isMobile) controls.lock();
            } else {
                if (controls.isLocked) controls.unlock();
                inv.style.display = 'flex';
                grid.innerHTML = '';
                
                // Populate Grid with buildable blocks (skip special actions)
                blockTypes.forEach((b, i) => {
                    if(b.isInventoryAction) return; 
                    const item = document.createElement('div');
                    item.className = 'inv-item';
                    item.innerHTML = `<img src="${getBlockTexture(b.material)}"><br>${b.name}`;
                    item.onclick = () => {
                        selectBlock(i);
                        inv.style.display = 'none';
                        if(!isMobile) controls.lock();
                    };
                    grid.appendChild(item);
                });
            }
        }

        // Helper to get texture for UI
        function getBlockTexture(mat) {
            if (!mat) return ''; // For special items
            if(Array.isArray(mat)) return mat[2].map.image.toDataURL();
            if(mat.map) return mat.map.image.toDataURL();
            return '';
        }

        // Update Hotbar UI Function
        function updateHotbarUI() {
            const bar = document.getElementById('hotbar');
            bar.innerHTML = ''; // Clear
            blockTypes.forEach((b, i) => {
                if (i > 6) return; // Limit hotbar size
                const slot = document.createElement('div');
                slot.className = i === selectedBlockIndex ? 'slot active' : 'slot';
                
                const num = document.createElement('span');
                num.innerText = i + 1;
                num.className = 'slot-num';
                slot.appendChild(num);

                if (b.isInventoryAction) {
                    slot.style.backgroundImage = `url(${textures.inventory.image.toDataURL()})`;
                } else {
                    slot.style.backgroundImage = `url(${getBlockTexture(b.material)})`;
                }
                
                const lbl = document.createElement('div');
                lbl.innerText = b.name;
                lbl.className = 'slot-name';
                slot.appendChild(lbl);

                slot.addEventListener('click', () => selectBlock(i));
                slot.addEventListener('touchstart', (e) => { e.preventDefault(); selectBlock(i); });
                bar.appendChild(slot);
            });
        }

        function selectBlock(index) {
            if (blockTypes[index].isInventoryAction) {
                toggleInventory();
                return;
            }
            selectedBlockIndex = index;
            updateHotbarUI();
        }

        // --- FX ---
        function spawnBreakParticles(pos, color) {
            const count = 5;
            for(let i=0; i<count; i++) {
                const p = document.createElement('div');
                p.className = 'break-particle';
                p.style.backgroundColor = color || '#888';
                const tx = (Math.random() - 0.5) * 100; 
                const ty = (Math.random() - 0.5) * 100;
                p.style.setProperty('--tx', `${tx}px`);
                p.style.setProperty('--ty', `${ty}px`);
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 500);
            }
        }

        function performAction(buttonType) {
            if (isDead || document.getElementById('inventory-screen').style.display === 'flex') return;
            
            raycaster.setFromCamera(center, camera);
            
            // Hand Animation
            if(!isMobile) {
                handGroup.position.set(HAND_DEF_POS.x, HAND_DEF_POS.y, HAND_DEF_POS.z);
                handGroup.rotation.set(HAND_DEF_ROT.x, HAND_DEF_ROT.y, HAND_DEF_ROT.z);
                handGroup.position.z -= 0.4; 
                handGroup.position.y += 0.1;
                handGroup.rotation.x -= 0.1; 
                setTimeout(() => {
                    handGroup.position.set(HAND_DEF_POS.x, HAND_DEF_POS.y, HAND_DEF_POS.z);
                    handGroup.rotation.set(HAND_DEF_ROT.x, HAND_DEF_ROT.y, HAND_DEF_ROT.z);
                }, 100);
            }

            // Check enemy hits
            const vIntersects = raycaster.intersectObjects(villains, true);
            if (vIntersects.length > 0 && vIntersects[0].distance < 6) {
                const hitObj = vIntersects[0].object;
                // Traverse up to find main mesh from core/parts
                let villainMesh = hitObj;
                while(villainMesh.parent && villainMesh.parent.type !== 'Scene') {
                     if (villainMesh.userData && villainMesh.userData.hp !== undefined) break;
                     villainMesh = villainMesh.parent;
                }
                
                if (villainMesh.userData.hp !== undefined) {
                    if (buttonType === 0) { // Attack
                         const hasSword = handGroup.children.some(c => c.userData.isSword);
                         const dmg = hasSword ? 40 : 10;
                         villainMesh.userData.hp -= dmg;
                         spawnBreakParticles(vIntersects[0].point, '#ff0000');
                         
                         // Knockback
                         const pushDir = new THREE.Vector3().subVectors(villainMesh.position, camera.position).normalize();
                         villainMesh.position.add(pushDir.multiplyScalar(2));
                         
                         showToast(`ENEMY HIT! HP: ${villainMesh.userData.hp}%`);
                         
                         if (villainMesh.userData.hp <= 0) {
                             scene.remove(villainMesh);
                             villains = villains.filter(v => v !== villainMesh);
                             showToast("TARGET ELIMINATED (+100 XP)");
                         }
                         return; // Stop raycast here
                    }
                }
            }

            // Check interacts (chests)
            let intersects = raycaster.intersectObjects(interactableObjects);
            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.distance < 5) {
                    if (hit.object.userData.isTreasure) {
                        const id = hit.object.userData.treasureId;
                        const treasure = TREASURES.find(t => t.id === id);
                        if (treasure && !treasure.found) {
                            treasure.found = true;
                            openTreasure(id);
                            scene.remove(hit.object);
                        }
                        return;
                    }
                }
            }

            // Check blocks for mine/build
            const allMeshes = [];
            Object.values(meshes).forEach(m => { if(m && m.parent) allMeshes.push(m); });
            allMeshes.push(...placedBlocks);
            
            intersects = raycaster.intersectObjects(allMeshes);
            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.distance < 8) {
                    let hitBlockPos = new THREE.Vector3();
                    if (hit.object.isInstancedMesh) {
                        const matrix = new THREE.Matrix4();
                        hit.object.getMatrixAt(hit.instanceId, matrix);
                        const pos = new THREE.Vector3();
                        matrix.decompose(pos, new THREE.Quaternion(), new THREE.Vector3());
                        hitBlockPos.copy(pos);
                    } else {
                        hitBlockPos.copy(hit.object.position);
                    }
                    hitBlockPos.x = Math.round(hitBlockPos.x);
                    hitBlockPos.y = Math.round(hitBlockPos.y);
                    hitBlockPos.z = Math.round(hitBlockPos.z);

                    if (buttonType === 0) { // Mine
                        spawnBreakParticles(hit.point, '#888'); 
                        if (hit.object.isInstancedMesh) {
                            const matrix = new THREE.Matrix4();
                            hit.object.getMatrixAt(hit.instanceId, matrix);
                            worldBlocks.delete(`${hitBlockPos.x},${hitBlockPos.y},${hitBlockPos.z}`);
                            matrix.scale(new THREE.Vector3(0,0,0)); 
                            hit.object.setMatrixAt(hit.instanceId, matrix);
                            hit.object.instanceMatrix.needsUpdate = true;

                            const meshKey = Object.keys(meshes).find(k => meshes[k] === hit.object);
                            if (meshKey && meshKey.includes('flower')) {
                                // Add flower to inventory logic here if needed
                                showToast("Harvested: " + meshKey.replace('flower', '') + " Flower");
                            }
                        } else {
                            scene.remove(hit.object);
                            placedBlocks = placedBlocks.filter(b => b !== hit.object);
                            worldBlocks.delete(`${hitBlockPos.x},${hitBlockPos.y},${hitBlockPos.z}`);
                        }
                    } else if (buttonType === 2) { // Build
                        // Check if current slot is inventory action
                        if (blockTypes[selectedBlockIndex].isInventoryAction) {
                            toggleInventory();
                            return;
                        }

                        const buildPos = hitBlockPos.clone().add(hit.face.normal);
                        const bx = Math.round(buildPos.x);
                        const by = Math.round(buildPos.y);
                        const bz = Math.round(buildPos.z);

                        if (!worldBlocks.has(`${bx},${by},${bz}`) && !waterBlocks.has(`${bx},${by},${bz}`)) {
                            const playerX = camera.position.x;
                            const playerY = camera.position.y - 1.6;
                            const playerZ = camera.position.z;
                            const blockMin = { x: bx - 0.5, y: by - 0.5, z: bz - 0.5 };
                            const blockMax = { x: bx + 0.5, y: by + 0.5, z: bz + 0.5 };
                            const playerMin = { x: playerX - 0.3, y: playerY, z: playerZ - 0.3 };
                            const playerMax = { x: playerX + 0.3, y: playerY + 1.8, z: playerZ + 0.3 };

                            const intersectX = (blockMin.x <= playerMax.x && blockMax.x >= playerMin.x);
                            const intersectY = (blockMin.y <= playerMax.y && blockMax.y >= playerMin.y);
                            const intersectZ = (blockMin.z <= playerMax.z && blockMax.z >= playerMin.z);

                            if (!(intersectX && intersectY && intersectZ)) {
                                const bData = blockTypes[selectedBlockIndex];
                                const buildGeo = bData.type.includes('flower') ? flowerGeometry : geometry;
                                const mesh = new THREE.Mesh(buildGeo, bData.material);
                                mesh.position.set(bx, by, bz);
                                scene.add(mesh);
                                placedBlocks.push(mesh);
                                worldBlocks.set(`${bx},${by},${bz}`, bData.type);
                                
                                mesh.scale.set(0,0,0);
                                let s = 0;
                                const grow = setInterval(() => {
                                    s += 0.2;
                                    mesh.scale.set(s,s,s);
                                    if(s>=1) clearInterval(grow);
                                }, 16);
                            }
                        }
                    }
                }
            }
        }

        let isShieldActive = false;
        let shieldTimer = null;

        function activateShield() {
            isShieldActive = true;
            showToast("SHIELD ACTIVE: 60s INVULNERABILITY");
            
            if (shieldTimer) clearTimeout(shieldTimer);
            shieldTimer = setTimeout(() => {
                isShieldActive = false;
                showToast("SHIELD EXPIRED!");
                const shieldObj = handGroup.children.find(c => c.userData.isShield);
                if(shieldObj) handGroup.remove(shieldObj);
            }, 60000);
        }

        function activateSpeedBoost() {
            speedBoostActive = true;
            showToast("SPEED BOOST ACTIVE: 30s");
            setTimeout(() => {
                speedBoostActive = false;
                showToast("SPEED BOOST EXPIRED");
            }, 30000);
        }

        function openTreasure(id) {
            const titleEl = document.getElementById('item-name');
            const contentEl = document.getElementById('dynamic-content');
            const overlay = document.getElementById('message-overlay');
            overlay.style.display = 'flex';
            controls.unlock();
            
            // AI Lore Generation
            (async () => {
                let itemDesc = "Unknown Artifact";
                if(id === 1) itemDesc = "Blade of the Grind";
                if(id === 2) itemDesc = "Glitch Shield";
                if(id === 3) itemDesc = "Medkit";
                if(id === 4) itemDesc = "Speed Boots";
                if(id === 5) itemDesc = "Full Heal Orb";
                if(id === 6) itemDesc = "Victory Crown";

                const lore = await callGemini(`Describe a legendary cyberpunk item called '${itemDesc}' found in a glitchy digital wasteland. 1 sentence max.`);
                if(contentEl) {
                    // Append lore to existing content
                    const p = document.createElement('p');
                    p.style.color = "#b388ff";
                    p.style.fontStyle = "italic";
                    p.style.marginTop = "10px";
                    p.innerText = '"' + lore + '"';
                    contentEl.appendChild(p);
                }
            })();

            if (id === 1) {
                equipItem('sword');
                triggerXPOrbs();
                titleEl.innerText = "⚔️ BLADE OF THE GRIND";
                contentEl.innerHTML = `<p>Damage: CRITICAL</p><p>Effect: Slay Procrastination</p>`;
            } else if (id === 2) {
                equipItem('shield');
                activateShield();
                triggerXPOrbs();
                titleEl.innerText = "🛡️ GLITCH SHIELD";
                contentEl.innerHTML = `<p>Durability: 60 Seconds</p><p>Effect: Invincibility</p>`;
            } else if (id === 3) {
                playerHP = Math.min(100, playerHP + 50);
                updateHealthUI();
                triggerXPOrbs();
                titleEl.innerText = "💊 MEDKIT";
                contentEl.innerHTML = `<p>Heals +50 HP</p><p>Effect: Restoration</p>`;
            } else if (id === 4) {
                activateSpeedBoost();
                triggerXPOrbs();
                titleEl.innerText = "⚡ SPEED BOOTS";
                contentEl.innerHTML = `<p>Speed: +50%</p><p>Duration: 30 Seconds</p>`;
            } else if (id === 5) {
                playerHP = 100;
                updateHealthUI();
                triggerXPOrbs();
                titleEl.innerText = "❤️ FULL HEAL";
                contentEl.innerHTML = `<p>HP Restored to 100%</p><p>Bonus: 500 XP</p>`;
            } else if (id === 6) {
                triggerFireworks();
                titleEl.innerText = "👑 VICTORY ROYALE";
                contentEl.innerHTML = `<p>Level 2026 Unlocked</p><p>Rank: LEGENDARY</p>`;
            }
        }

        // VFX Functions
        function triggerXPOrbs() {
            const overlay = document.getElementById('message-overlay');
            for (let i = 0; i < 30; i++) {
                const orb = document.createElement('div');
                orb.className = 'xp-orb';
                const tx = (Math.random() - 0.5) * 600; 
                const ty = (Math.random() - 0.5) * 600; 
                orb.style.setProperty('--tx', `${tx}px`);
                orb.style.setProperty('--ty', `${ty}px`);
                overlay.appendChild(orb);
            }
        }

        function triggerFireworks(container = null) {
            const parent = container || document.getElementById('message-overlay');
            for(let i=0; i<10; i++) {
                setTimeout(() => {
                    const firework = document.createElement('div');
                    firework.className = 'firework';
                    firework.style.left = Math.random() * 80 + 10 + '%';
                    firework.style.setProperty('--fy', Math.random() * 50 + 10 + '%');
                    firework.style.backgroundColor = i % 2 === 0 ? '#00ff00' : '#a335ee';
                    parent.appendChild(firework);
                    
                    setTimeout(() => {
                         for(let j=0; j<20; j++) {
                            const spark = document.createElement('div');
                            spark.className = 'spark';
                            spark.style.left = firework.style.left;
                            spark.style.top = firework.style.getPropertyValue('--fy');
                            spark.style.backgroundColor = firework.style.backgroundColor;
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * 200 + 50;
                            spark.style.setProperty('--sx', `${Math.cos(angle)*dist}px`);
                            spark.style.setProperty('--sy', `${Math.sin(angle)*dist}px`);
                            parent.appendChild(spark);
                         }
                    }, 1000);
                }, i * 300);
            }
        }

        window.addEventListener('mousedown', (e) => {
            if (!controls.isLocked && !isMobile) return;
            performAction(e.button);
        });

        // --- NEW FEATURES: VILLAIN & SAFEHOUSE ---
        let villains = [];
        let safeHouseGroup = null;
        let isPlayerSafe = false;
        const SAFEHOUSE_POS = { x: -40, y: 10, z: -40 };
        
        function createVillainMesh() {
            const villainGeo = new THREE.DodecahedronGeometry(1.5, 0);
            const villainMat = new THREE.MeshPhongMaterial({ 
                color: 0x000000, 
                emissive: 0xff0000,
                emissiveIntensity: 0.5,
                wireframe: true 
            });
            const v = new THREE.Mesh(villainGeo, villainMat);
            const core = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), new THREE.MeshBasicMaterial({color:0xff0000}));
            v.add(core);
            v.userData.hp = 100; // HP
            v.userData.maxHp = 100;
            return v;
        }

        function spawnVillains(count = 3, savedData = null) {
            villains.forEach(v => scene.remove(v));
            villains = [];

            if (savedData) {
                savedData.forEach(data => {
                    const v = createVillainMesh();
                    v.position.set(data.pos.x, data.pos.y, data.pos.z);
                    v.userData.state = data.state;
                    v.userData.roamTarget = new THREE.Vector3(data.roamTarget.x, data.roamTarget.y, data.roamTarget.z);
                    v.userData.roamTimer = data.roamTimer;
                    v.userData.hp = data.hp !== undefined ? data.hp : 100; // Restore HP
                    scene.add(v);
                    villains.push(v);
                });
            } else {
                for(let i=0; i<count; i++) {
                    const v = createVillainMesh();
                    let vx, vz;
                    do {
                        vx = (Math.random() - 0.5) * 120;
                        vz = (Math.random() - 0.5) * 120;
                    } while(Math.sqrt(vx*vx + vz*vz) < 40); 

                    v.position.set(vx, 20, vz);
                    v.userData.state = 'roam';
                    v.userData.roamTarget = new THREE.Vector3(vx, 20, vz);
                    v.userData.roamTimer = 0;
                    scene.add(v);
                    villains.push(v);
                }
            }
        }

        function spawnSafeHouse() {
            safeHouseGroup = new THREE.Group();
            const domeGeo = new THREE.BoxGeometry(8, 8, 8);
            const domeMat = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.2, 
                side: THREE.DoubleSide 
            });
            const dome = new THREE.Mesh(domeGeo, domeMat);
            safeHouseGroup.add(dome);

            const edges = new THREE.EdgesGeometry(domeGeo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial( { color: 0x00ffff } ) );
            safeHouseGroup.add(line);

            safeHouseGroup.position.set(SAFEHOUSE_POS.x, SAFEHOUSE_POS.y, SAFEHOUSE_POS.z);
            scene.add(safeHouseGroup);

            for(let dx=-4; dx<=4; dx++) {
                for(let dz=-4; dz<=4; dz++) {
                    addBlock('obsidian', SAFEHOUSE_POS.x + dx, SAFEHOUSE_POS.y - 4, SAFEHOUSE_POS.z + dz);
                }
            }
        }

        function updateVillain(delta) {
            if (villains.length === 0 || isPlayerSafe || isDead) return;

            const detectionRange = 35; 
            const chaseSpeed = 7.5; // REDUCED SPEED (was 11)   
            const roamSpeed = 3;       
            
            const warningEl = document.getElementById('chase-warning');
            let anyChasing = false;
            let closestDist = Infinity;

            villains.forEach(villain => {
                const distToPlayer = villain.position.distanceTo(camera.position);
                if(distToPlayer < closestDist) closestDist = distToPlayer;

                if (distToPlayer < detectionRange) {
                    villain.userData.state = 'chase';
                } else if (villain.userData.state === 'chase' && distToPlayer > detectionRange * 1.5) {
                    villain.userData.state = 'roam';
                }

                let targetPos = new THREE.Vector3();
                let currentSpeed = 0;

                if (villain.userData.state === 'chase') {
                    anyChasing = true;
                    targetPos.copy(camera.position);
                    currentSpeed = chaseSpeed;
                } else {
                    villain.userData.roamTimer -= delta;
                    if (villain.userData.roamTimer <= 0) {
                        const theta = Math.random() * Math.PI * 2;
                        const r = 20 + Math.random() * 20;
                        villain.userData.roamTarget.set(
                            villain.position.x + Math.cos(theta) * r,
                            Math.max(10, villain.position.y), 
                            villain.position.z + Math.sin(theta) * r
                        );
                        villain.userData.roamTimer = 4 + Math.random() * 4;
                    }
                    targetPos.copy(villain.userData.roamTarget);
                    currentSpeed = roamSpeed;
                }

                // --- COLLISION AWARE MOVEMENT ---
                const direction = new THREE.Vector3().subVectors(targetPos, villain.position).normalize();
                const nextPos = villain.position.clone().add(direction.multiplyScalar(currentSpeed * delta));
                
                // Simple Check: Is target block occupied?
                // We check waist level to block movement
                const checkX = Math.round(nextPos.x);
                const checkY = Math.round(nextPos.y); 
                const checkZ = Math.round(nextPos.z);
                
                // Also check feet to ensure not clipping into ground excessively, but main blocker is walls
                const blocked = worldBlocks.has(`${checkX},${checkY},${checkZ}`) || 
                                worldBlocks.has(`${checkX},${checkY+1},${checkZ}`);

                if (!blocked) {
                    villain.position.copy(nextPos);
                } else {
                    // Slide along X or Z if possible
                    // Basic fallback: just don't move. 
                    // To improve, we could try moving X only or Z only, but stopping is safer for "home defense".
                }

                const targetY = (villain.userData.state === 'chase') ? camera.position.y + 1 : 12;
                villain.position.y += (targetY - villain.position.y) * delta * 2;

                villain.rotation.x += delta * 2;
                villain.rotation.y += delta * 2;
                villain.lookAt(targetPos);

                // --- COLLISION WITH PLAYER ---
                if (distToPlayer < 2 && Date.now() - lastDamageTime > 1000) {
                    if (isShieldActive) {
                        const pushDir = new THREE.Vector3().subVectors(villain.position, camera.position).normalize();
                        villain.position.add(pushDir.multiplyScalar(5));
                        showToast("SHIELD BLOCKED DAMAGE!");
                    } else {
                        // Take Damage
                        takeDamage(20);
                        // Bounce villain back
                        const pushDir = new THREE.Vector3().subVectors(villain.position, camera.position).normalize();
                        villain.position.add(pushDir.multiplyScalar(8));
                        showToast("YOU TOOK DAMAGE! -20 HP");
                    }
                }
            });

            if (anyChasing) {
                warningEl.style.display = 'block';
                warningEl.innerText = "⚠ RUN! IT SEES YOU! ⚠";
                warningEl.style.color = "#ff0000";
                warningEl.style.opacity = 1;
            } else if (closestDist < detectionRange * 1.5) {
                warningEl.style.display = 'block';
                warningEl.innerText = "Something is watching...";
                warningEl.style.color = "#ffaaaa";
                warningEl.style.opacity = 0.5;
            } else {
                warningEl.style.display = 'none';
            }
        }

        function checkSafeZone() {
            if (!safeHouseGroup) return;
            const dist = new THREE.Vector3(camera.position.x, 0, camera.position.z).distanceTo(new THREE.Vector3(SAFEHOUSE_POS.x, 0, SAFEHOUSE_POS.z));
            
            if (dist < 5) {
                if (!isPlayerSafe) {
                    isPlayerSafe = true;
                    showToast("SAFE ZONE ENTERED 🛡️");
                    document.getElementById('chase-warning').style.display = 'none';
                }
            } else {
                isPlayerSafe = false;
            }
        }

        // --- LOOP ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const clock = new THREE.Clock();
        
        // MINIMAP CONTEXT
        const mapCanvas = document.getElementById('minimap');
        const mapCtx = mapCanvas.getContext('2d');
        const mapScale = 1.2;

        function drawMinimap() {
            mapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            mapCtx.fillRect(0, 0, 150, 150);
            
            const cx = 75;
            const cy = 75;
            
            // Draw Path Line
            mapCtx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            mapCtx.lineWidth = 4;
            mapCtx.beginPath();
            const points = [{x:0, z:0}, {x:15, z:15}, {x:30, z:30}, {x:50, z:50}];
            points.forEach((p, i) => {
                const mx = (p.x - camera.position.x) * mapScale + cx;
                const my = (p.z - camera.position.z) * mapScale + cy;
                if (i===0) mapCtx.moveTo(mx, my); else mapCtx.lineTo(mx, my);
            });
            mapCtx.stroke();

            // Treasures
            TREASURES.forEach(t => {
                if (!t.found) {
                     const tx = (t.x - camera.position.x) * mapScale + cx;
                     const ty = (t.z - camera.position.z) * mapScale + cy;
                     mapCtx.fillStyle = '#ff00ff';
                     mapCtx.fillRect(tx-3, ty-3, 6, 6);
                }
            });

            // Draw SafeHouse (Blue Square)
            if (safeHouseGroup) {
                const sx = (SAFEHOUSE_POS.x - camera.position.x) * mapScale + cx;
                const sy = (SAFEHOUSE_POS.z - camera.position.z) * mapScale + cy;
                mapCtx.fillStyle = '#00ffff';
                mapCtx.fillRect(sx-4, sy-4, 8, 8);
                mapCtx.strokeStyle = '#fff';
                mapCtx.lineWidth = 1;
                mapCtx.strokeRect(sx-4, sy-4, 8, 8);
            }

            // Draw Village (Orange Markers)
            const villX = (VILLAGE_POS.x - camera.position.x) * mapScale + cx;
            const villZ = (VILLAGE_POS.z - camera.position.z) * mapScale + cy;
            mapCtx.fillStyle = '#FFA500'; 
            // Represent houses
            mapCtx.fillRect(villX, villZ, 6, 6);
            mapCtx.fillRect(villX + 8, villZ + 6, 4, 4);
            mapCtx.fillRect(villX - 8, villZ + 4, 4, 4);
            mapCtx.fillRect(villX, villZ + 10, 5, 4);

            // Draw Villains (Red Dots)
            villains.forEach(v => {
                const vx = (v.position.x - camera.position.x) * mapScale + cx;
                const vz = (v.position.z - camera.position.z) * mapScale + cy;
                
                // Only draw if within minimap bounds (roughly)
                if (vx > 0 && vx < 150 && vz > 0 && vz < 150) {
                    mapCtx.fillStyle = '#ff0000';
                    mapCtx.beginPath();
                    mapCtx.arc(vx, vz, 4, 0, Math.PI*2);
                    mapCtx.fill();
                }
            });

            // Player Arrow
            mapCtx.save();
            mapCtx.translate(cx, cy);
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const angle = Math.atan2(dir.x, dir.z); // Standard math angle
            mapCtx.rotate(-angle); 
            mapCtx.fillStyle = '#00ff00';
            mapCtx.beginPath();
            mapCtx.moveTo(0, -6);
            mapCtx.lineTo(5, 5);
            mapCtx.lineTo(-5, 5);
            mapCtx.fill();
            mapCtx.restore();
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1); 
            updatePlayer(delta);
            updateVillain(delta);
            checkSafeZone();
            drawMinimap();
            
            // Arrow Logic
            let target = TREASURES.find(t => !t.found);
            // If all loot found, point to safe house
            if (!target) {
                target = { x: SAFEHOUSE_POS.x, z: SAFEHOUSE_POS.z };
                document.getElementById('guide-text').innerText = "ESCAPE TO SAFE HOUSE!";
                document.getElementById('guide-text').style.color = "#00ffff";
            } else {
                 document.getElementById('guide-text').innerText = `LOOT: ${Math.round(Math.sqrt((target.x - camera.position.x)**2 + (target.z - camera.position.z)**2))}m`;
            }

            if(target) {
                const dx = target.x - camera.position.x;
                const dz = target.z - camera.position.z;
                document.getElementById('guide-arrow').style.transform = `rotate(${Math.atan2(dx, dz) - Math.atan2(camera.getWorldDirection(new THREE.Vector3()).x, camera.getWorldDirection(new THREE.Vector3()).z) * (180/Math.PI)}deg)`;
            }

            renderer.render(scene, camera);
        }

        // Initialize Animation Loop, but don't generate world yet.
        animate();
    </script>
</body>
</html>